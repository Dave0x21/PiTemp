#!/usr/bin/env python3

import datetime
import logging
import signal
import sqlite3
import sys
from threading import Event, Thread
from time import sleep

from flask import (Flask, jsonify, render_template,
                   request, send_from_directory)
from werkzeug.serving import make_server

RESPONSE = {}
DB = "/etc/pitemp/pitemp.db"

logging.basicConfig(level=logging.DEBUG)

# for triggering the shutdown procedure when a signal is detected
keyboard_trigger = Event()


def signal_handler(signal, frame):
    logging.info('Signal detected. Stopping threads.')
    keyboard_trigger.set()


DIRECTORY_PATH = 'static'
HOST = "0.0.0.0"
WEB_PORT = 80
app = Flask(__name__, static_url_path='')


class WebServerThread(Thread):
    '''
    Class to make the launch of the flask server non-blocking.
    Also adds shutdown functionality to it.
    '''

    def __init__(self, app, host, port):
        Thread.__init__(self)
        self.srv = make_server(host, port, app)
        self.ctx = app.app_context()
        self.ctx.push()

    def run(self):
        logging.info('Starting PiTemp server')
        self.srv.serve_forever()

    def shutdown(self):
        logging.info('Stopping PiTemp server')
        self.srv.shutdown()

################
#     UTILS    #
################

def dict_factory_array(cursor, row):
    global RESPONSE

    for idx, col in enumerate(cursor.description):
        if col[0] not in RESPONSE:
            RESPONSE[col[0]] = []

        RESPONSE[col[0]].append(row[idx])
    return RESPONSE

def dict_factory_simple(cursor, row):
    d = {} 
    for idx, col in enumerate(cursor.description):
        d[col[0]] = (row[idx])
    return d

def get_query(measure, msg):
    if measure == 'temperature':
        query = 'SELECT time, temp '
    elif measure == 'humidity':
        query = 'SELECT time, humidity '
    elif measure == 'light':
        query = 'SELECT time, humidity '
    else:
        return 'Invalid request'
    
    query += msg

    return query

def get_data_array(query):
    global RESPONSE
    RESPONSE = {}
    
    conn = sqlite3.connect(DB)
    conn.row_factory = dict_factory_array
    c = conn.cursor()
    c.execute(query)

    data = c.fetchall
    conn.close()

    return jsonify(data)


################
#   WEB PAGE   #
################

@app.route("/")
def index():
    return render_template("index.html")


@app.route("/day_view")
def day_view():
    return render_template("day.html")


@app.route("/custom_view")
def custom_view():
    return render_template("custom_range.html")


###############
#     API     #
###############

@app.route("/api/current_readings")
def api_current_readings():
    query = 'select temp, humidity, light, pressure, trend as pressure_trend from pitemp order by id desc limit 1'
    
    conn = sqlite3.connect(DB)
    conn.row_factory = dict_factory_simple
    c = conn.cursor()
    c.execute(query)

    data = c.fetchone()

    conn.close()

    return jsonify(data)
    
@app.route("/api/last_24h/<measure>")
def api_last_24h(measure):

    query  = get_query(measure, 'FROM pitemp WHERE time >= datetime("now", "-24 hours", "localtime")')

    if query == 'Invalid request':
        return jsonify({'error': query})
    else:
        return get_data_array(query)
    

@app.route("/api/day/<day>/<measure>")
def api_day(day, measure):
    query  = get_query(measure, 'FROM pitemp WHERE (time LIKE "{}%")'.format(day))

    if query == 'Invalid request':
        return jsonify({'error': query})
    else:
        return get_data_array(query)


@app.route("/api/range/<start>/<end>/<measure>")
def api_range(start, end, measure):
    query  = get_query(measure, 'FROM pitemp time BETWEEN date("{}") AND date("{}")'.format(start, end))

    if query == 'Invalid request':
        return jsonify({'error': query})
    else:
        return get_data_array(query)
    

@app.route("/static/<path:path>")
def send_static(path):
    return send_from_directory(DIRECTORY_PATH, path)


if __name__ == "__main__":
    # registering both types of signals
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # starting the web server
    webserver = WebServerThread(app, HOST, WEB_PORT)
    webserver.start()
    logging.info("Started PiTemp web server")

    # and run it indefinitely
    while not keyboard_trigger.is_set():
        sleep(0.5)

    # until some keyboard event is detected
    logging.info("Keyboard event detected")

    # trigger shutdown procedure
    webserver.shutdown()

    # and finalize shutting them down
    webserver.join()
    logging.info("Stopped all threads")

    sys.exit(0)
