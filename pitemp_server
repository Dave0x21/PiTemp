#!/usr/bin/env python3

import datetime
import json
import logging
import signal
import sqlite3
import sys
from threading import Event, Thread
from time import sleep

from flask import (Flask, Response, jsonify, render_template, request,
                   send_from_directory, url_for)
from werkzeug.serving import make_server

RESPONSE = {'time': [], 'temp': [], 'humidity': [], 'light': [], 'pressure': [], 'trend': [], 
            'min_max': {"temp": [0, 0], "hum": [0, 0], "lux": [0, 0], "pres": [0, 0]}, 
            'media': {"temp": 0, "hum": 0, "lux": 0, "pres": 0}}
DB = "/etc/pitemp/pitemp.db"


logging.basicConfig(level=logging.DEBUG)

# for triggering the shutdown procedure when a signal is detected
keyboard_trigger = Event()


def signal_handler(signal, frame):
    logging.info('Signal detected. Stopping threads.')
    keyboard_trigger.set()


DIRECTORY_PATH = 'static'
HOST = "0.0.0.0"
WEB_PORT = 80
app = Flask(__name__, static_url_path='')


class WebServerThread(Thread):
    '''
    Class to make the launch of the flask server non-blocking.
    Also adds shutdown functionality to it.
    '''

    def __init__(self, app, host, port):
        Thread.__init__(self)
        self.srv = make_server(host, port, app)
        self.ctx = app.app_context()
        self.ctx.push()

    def run(self):
        logging.info('Starting PiTemp server')
        self.srv.serve_forever()

    def shutdown(self):
        logging.info('Stopping PiTemp server')
        self.srv.shutdown()


def dict_factory(cursor, row):
    global RESPONSE
    for idx, col in enumerate(cursor.description):
        RESPONSE[col[0]].append(row[idx])
    return RESPONSE


def get_data(query):
    global RESPONSE

    RESPONSE = {'time': [], 'temp': [], 'humidity': [], 'light': [], 'pressure': [], 'trend': [], 
                'min_max': {"temp": [0, 0], "hum": [0, 0], "lux": [0, 0], "pres": [0, 0]}, 
                'media': {"temp": 0, "hum": 0, "lux": 0, "pres": 0}}

    conn = sqlite3.connect(DB)
    conn.row_factory = dict_factory
    c = conn.cursor()
    c.execute(query)
    c.fetchall()
    
    try:
        tot = float(len(RESPONSE['temp']))

        RESPONSE['media']['temp'] = "{:.1f}".format(sum(RESPONSE['temp']) / tot)
        RESPONSE['media']['hum'] = "{:.1f}".format(sum(RESPONSE['humidity']) / tot)
        RESPONSE['media']['lux'] = "{:.1f}".format(sum(RESPONSE['light']) / tot)
        RESPONSE['media']['pres'] = "{:.1f}".format(sum(RESPONSE['pressure']) / tot)

        RESPONSE['min_max']['temp'] = [min(RESPONSE['temp']), max(RESPONSE['temp'])]
        RESPONSE['min_max']['hum'] = [min(RESPONSE['humidity']), max(RESPONSE['humidity'])]
        RESPONSE['min_max']['lux'] = [min(RESPONSE['light']), max(RESPONSE['light'])]
        RESPONSE['min_max']['pres'] = [min(RESPONSE['pressure']), max(RESPONSE['pressure'])]
    except ZeroDivisionError:
        RESPONSE['media'] = {"temp": 0, "hum": 0, "lux": 0, "pres": 0}
        RESPONSE['min_max'] = {"temp": [0, 0], "hum": [0, 0], "lux": [0, 0], "pres": [0, 0]}



@app.route("/")
def index():
    global RESPONSE

    get_data("SELECT * FROM pitemp WHERE time >= datetime('now', '-24 hours', 'localtime')")
    return render_template("index.html", response = RESPONSE)


@app.route("/day_view", methods=['GET', 'POST'])
def day_view():
    global RESPONSE

    if request.method == 'POST':
        day = request.get_data()
        day = [x.decode() for x in day.split()[1:4]]
        day = ' '.join(day)

        date = datetime.datetime.strptime(day, '%b %d %Y')
        query = "SELECT * from pitemp WHERE (time LIKE '{}%')".format(datetime.datetime.strftime(date, "%Y-%m-%d"))
        get_data(query)

        return jsonify(dict(RESPONSE, **{"day": day})), 200
    else:
        date = datetime.datetime.now() - datetime.timedelta(days=1)
        query = "SELECT * from pitemp WHERE (time LIKE '{}%')".format(datetime.datetime.strftime(date, "%Y-%m-%d"))
        date = datetime.datetime.strftime(date, "%b %d %Y")
        get_data(query)
        return render_template("day.html", data=dict(RESPONSE, **{'day': date}))


@app.route("/custom_view", methods=['GET', 'POST'])
def custom_view():
    global RESPONSE
    
    if request.method == 'POST':
        days = request.get_data()
        days = days.decode()
        days = days.split(" - ")
        days[0] = datetime.datetime.strptime(days[0], '%b %d %Y')
        days[1] = datetime.datetime.strptime(days[1], '%b %d %Y')
        
        query = "SELECT * from pitemp WHERE time BETWEEN date('{}') AND date('{}')".format(datetime.datetime.strftime(days[0], "%Y-%m-%d"), datetime.datetime.strftime(days[1], "%Y-%m-%d"))

        get_data(query)

        return jsonify(RESPONSE), 200
    else:
        end = datetime.datetime.now()
        start = end - datetime.timedelta(days=6)
        query = "SELECT * FROM pitemp WHERE time >= datetime('now', '-6 days', 'localtime')"
        
        get_data(query)

        date = [datetime.datetime.strftime(start, "%b %d %Y"), datetime.datetime.strftime(end, "%b %d %Y")]
        return render_template("custom_range.html", data=dict(RESPONSE, **{'days': date}))



@app.route("/static/<path:path>")
def send_static(path):
    return send_from_directory(DIRECTORY_PATH, path)


if __name__ == "__main__":
    # registering both types of signals
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # starting the web server
    webserver = WebServerThread(app, HOST, WEB_PORT)
    webserver.start()
    logging.info("Started PiTemp web server")

    # and run it indefinitely
    while not keyboard_trigger.is_set():
        sleep(0.5)

    # until some keyboard event is detected
    logging.info("Keyboard event detected")

    # trigger shutdown procedure
    webserver.shutdown()

    # and finalize shutting them down
    webserver.join()
    logging.info("Stopped all threads")

    sys.exit(0)
